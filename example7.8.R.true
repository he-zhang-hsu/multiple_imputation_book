library(R2WinBUGS);
library(MASS);
library(mice);
library(norm);
library(mix);
# library(HI);
options(digits=4);
rm(list=ls());

model0.file <- system.file(package="R2WinBUGS", "model", "logitmodel_missinginteraction_JMforR.txt")
# Let's take a look:
file.show(model0.file)

model1.file <- system.file(package="R2WinBUGS", "model", "logitmodel_missinginteraction_fcsforR.txt")
# Let's take a look:
file.show(model1.file)


model2.file <- system.file(package="R2WinBUGS", "model", "logitmodel_missinginteraction_fcs_mix_forR.txt")
# Let's take a look:
file.show(model2.file)





# setwd('\\\\cdc.gov\\private\\L728\\book\\example8.4')

# generate the logistic outcome;
beta0=-1.5;
beta1=1/3;
beta2=1/6;

# generate the univariate normal x variable;
mu=2;
sigma=1;


rowobs=1000;
cycle_no=1000;
mi_no=50;

# matrices holding the parameter estimates;

BD_slope_vec=BD_slope_var_vec=rep(NA, cycle_no);
CC_slope_vec=CC_slope_var_vec=rep(NA, cycle_no);
bugs_slope_mat=bugs_slope_var_mat=pas_slope_mat=pas_slope_var_mat=jav_slope_mat=jav_slope_var_mat=matrix(NA, cycle_no, mi_no);


# generate data for example 8.5
for (cycle in cycle_no:cycle_no)

{
set.seed(cycle);

x=mu+sqrt(sigma)*rnorm(rowobs);

y2=rbinom(rowobs,size=1,prob=exp(beta0+beta1*x+beta2*x^2)/(1+exp(beta0+beta1*x+beta2*x^2)));


# apply the missing cases to complete data;
# missing at random;

# alpha0=2;

# alpha1=-2;

# missing_indi=rbinom(rowobs,size=1,prob=1/(1+exp(alpha0+alpha1*y2)));

# missing completely at random;

missing_indi=cbind(rbinom(rowobs,size=1,prob=0.20), rbinom(rowobs,size=1, prob=0.20));

missing_indi_x=missing_indi[,1];
missing_indi_y=missing_indi[,2];

y2_miss=y2;
x_miss=x;

# y2_miss[miss_indi==1]=NA;
# miss_seq=cbind(seq(1,rowobs,1), miss_indi)[miss_indi==1,1];

x_miss[missing_indi_x==1]=NA;
y2_miss[missing_indi_y==1]=NA;

# before deletion analysis;
# compelete data analysis;

# logistic regression coefficient for the slope of x^2;
BD_logistic=summary(glm(y2~x+I(x^2), family=binomial(link="logit")));
BD_slope_vec[cycle]=BD_logistic$coeff[3,1];
BD_slope_var_vec[cycle]=BD_logistic$coeff[3,2]^2;

# logistic regression coefficient for the slope of x^2;
CC_logistic=summary(glm(y2_miss~x_miss+I(x_miss^2), family=binomial(link="logit")));
CC_slope_vec[cycle]=CC_logistic$coeff[3,1];
CC_slope_var_vec[cycle]=CC_logistic$coeff[3,2]^2;


# JM winbugs imputation;


M=rowobs;

gibbs_no=10000;



process_stage2_data_simulate_JM=list("M","y2_miss", "x_miss");
process_stage2_init_JM= function(){list(beta0=-1.5, beta1=1/3, beta2=1/6, mu=2, tau=1)};
process_stage2_parameters_JM=c("x_impute", "y2_impute");



process_stage2.sim.JM <- bugs(data=process_stage2_data_simulate_JM, inits=process_stage2_init_JM, parameters=process_stage2_parameters_JM, model.file=model0.file,
    n.chains=1, n.iter=gibbs_no, n.burnin=gibbs_no/2, n.thin=gibbs_no/(2*mi_no), bugs.seed=cycle,
    bugs.directory="C:/Users/Guanghui He/Personal/Yulei/research/winbugs14_full_patched/WinBUGS14/", summary.only=FALSE, debug=FALSE,
    working.directory=NULL, clearWD=TRUE);


attach.bugs(process_stage2.sim.JM);
rm(process_stage2.sim.JM);

y2_completed_bugs_JM=y2_miss;
x_completed_bugs_JM=x_miss;

for (i in 1:mi_no)
{
x_completed_bugs_JM[missing_indi_x==1]=x_impute[i,];
y2_completed_bugs_JM[missing_indi_y==1]=y2_impute[i,];

# logistic regression coefficient for x-square slope;
bugs_logistic=summary(glm(y2_completed_bugs_JM~x_completed_bugs_JM+I(x_completed_bugs_JM^2), family=binomial(link="logit")));
bugs_slope_mat[cycle,i]=bugs_logistic$coeff[3,1];
bugs_slope_var_mat[cycle,i]=bugs_logistic$coeff[3,2]^2;

}

# winbugs using FCS;

process_stage2_data_simulate_FCS=list("M","y2_miss", "x_miss");
process_stage2_init_FCS= function(){list(beta0=-1.5, beta1=1/3, beta2=1/6, alpha0=2, alpha1=0, tau=1)};
process_stage2_parameters_FCS=c("x_impute", "y2_impute");

process_stage2.sim.FCS <- bugs(data=process_stage2_data_simulate_FCS, inits=process_stage2_init_FCS, parameters=process_stage2_parameters_FCS, model.file=model1.file,
    n.chains=1, n.iter=gibbs_no, n.burnin=gibbs_no/2, n.thin=gibbs_no/(2*mi_no), bugs.seed=cycle,
    bugs.directory="C:/Users/Guanghui He/Personal/Yulei/research/winbugs14_full_patched/WinBUGS14/", summary.only=FALSE, debug=FALSE,
    working.directory=NULL, clearWD=TRUE);



attach.bugs(process_stage2.sim.FCS);
rm(process_stage2.sim.FCS);


# passive imputation;
y2_completed_passive=y2_miss;
x_completed_passive=x_miss;
for (i in 1:mi_no)
{
x_completed_passive[missing_indi_x==1]=x_impute[i,];
y2_completed_passive[missing_indi_y==1]=y2_impute[i,];



# logistic regression coefficient for x-square slope;
pas_logistic=summary(glm(y2_completed_passive~x_completed_passive+I(x_completed_passive^2), family=binomial(link="logit")));
pas_slope_mat[cycle,i]=pas_logistic$coeff[3,1];
pas_slope_var_mat[cycle,i]=pas_logistic$coeff[3,2]^2;
}

# winbugs using FCS, a more general model for X;

process_stage2_data_simulate_FCS_mix=list("M","y2_miss", "x_miss");
process_stage2_init_FCS_mix= function(){list(beta0=-1.5, beta1=1/3, beta2=1/6, mu=c(2,2), tau=c(1,1))};
process_stage2_parameters_FCS_mix=c("x_impute", "y2_impute");

process_stage2.sim.FCS.mix <- bugs(data=process_stage2_data_simulate_FCS_mix, inits=process_stage2_init_FCS_mix, parameters=process_stage2_parameters_FCS_mix, model.file=model2.file,
    n.chains=1, n.iter=gibbs_no, n.burnin=gibbs_no/2, n.thin=gibbs_no/(2*mi_no), bugs.seed=cycle,
    bugs.directory="C:/Users/Guanghui He/Personal/Yulei/research/winbugs14_full_patched/WinBUGS14/", summary.only=FALSE, 
    working.directory=NULL, clearWD=TRUE, debug=FALSE);

# write.table(cbind(y2_miss, x_miss), row.name=FALSE, file="C:/Users/WDQ7/book_program/testdata.txt");


attach.bugs(process_stage2.sim.FCS.mix);
rm(process_stage2.sim.FCS.mix);



# just another variable imputation
y2_completed_jav=y2_miss;
x_completed_jav=x_miss;
for (i in 1:mi_no)
{
x_completed_jav[missing_indi_x==1]=x_impute[i,];
y2_completed_jav[missing_indi_y==1]=y2_impute[i,];

# multiple imputation analysis;

# logistic regression coefficient for x1 slope;
jav_logistic=summary(glm(y2_completed_jav~x_completed_jav+I(x_completed_jav^2), family=binomial(link="logit")));
jav_slope_mat[cycle,i]=jav_logistic$coeff[3,1];
jav_slope_var_mat[cycle,i]=jav_logistic$coeff[3,2]^2;



}

cat("the cycle is", cycle, "\n");

}

# the end of mulitple imputation;

##########################################################################
# slope estimand;

# complete-data analysis;

true_slope=mean(BD_slope_vec);
true_slope;


# performance;
BD_slope_mse=mean((BD_slope_vec-true_slope)^2);
BD_slope_mse;

# lower and upper 95% CI;
BD_slope_low95_vec=BD_slope_vec-1.96*sqrt(BD_slope_var_vec);
BD_slope_up95_vec=BD_slope_vec+1.96*sqrt(BD_slope_var_vec);

BD_slope_length=mean(BD_slope_up95_vec-BD_slope_low95_vec);
BD_slope_length;

BD_slope_cov=(BD_slope_low95_vec < true_slope)*(BD_slope_up95_vec > true_slope);
mean(BD_slope_cov);

# variance estimates;
mean(sqrt(BD_slope_var_vec));
sqrt(var(BD_slope_vec));


# complete-case analysis;
CC_slope_bias=mean(CC_slope_vec)-true_slope;
CC_slope_bias;

CC_slope_bias/true_slope;

CC_slope_mse=mean((CC_slope_vec-true_slope)^2);
CC_slope_mse;

# lower and upper 95% CI;
CC_slope_low95_vec=CC_slope_vec-1.96*sqrt(CC_slope_var_vec);
CC_slope_up95_vec=CC_slope_vec+1.96*sqrt(CC_slope_var_vec);

CC_slope_length=mean(CC_slope_up95_vec-CC_slope_low95_vec);
CC_slope_length;

CC_slope_cov=(CC_slope_low95_vec < true_slope)*(CC_slope_up95_vec > true_slope);

mean(CC_slope_cov);

# variance estimates;
mean(sqrt(CC_slope_var_vec));
sqrt(var(CC_slope_vec));


# multiple imputation estimates;

bugs_mi_mean=rep(NA, cycle_no);
bugs_mi_var=rep(NA, cycle_no);
bugs_mi_df=rep(NA, cycle_no);
bugs_mi_f=rep(NA, cycle_no);

pas_mi_mean=rep(NA, cycle_no);
pas_mi_var=rep(NA, cycle_no);
pas_mi_df=rep(NA, cycle_no);
pas_mi_f=rep(NA, cycle_no);

jav_mi_mean=rep(NA, cycle_no);
jav_mi_var=rep(NA, cycle_no);
jav_mi_df=rep(NA, cycle_no);
jav_mi_f=rep(NA, cycle_no);



for (i in 1:cycle_no)
{
bugs_summary=pool.scalar(bugs_slope_mat[i,], bugs_slope_var_mat[i,], n=rowobs);
bugs_mi_mean[i]=bugs_summary$qbar;
bugs_mi_var[i]=bugs_summary$t;
bugs_mi_df[i]=bugs_summary$df;
bugs_mi_f[i]=bugs_summary$f;

pas_summary=pool.scalar(pas_slope_mat[i,], pas_slope_var_mat[i,], n=rowobs);
pas_mi_mean[i]=pas_summary$qbar;
pas_mi_var[i]=pas_summary$t;
pas_mi_df[i]=pas_summary$df;
pas_mi_f[i]=pas_summary$f;


jav_summary=pool.scalar(jav_slope_mat[i,], jav_slope_var_mat[i,], n=rowobs);
jav_mi_mean[i]=jav_summary$qbar;
jav_mi_var[i]=jav_summary$t;
jav_mi_df[i]=jav_summary$df;
jav_mi_f[i]=jav_summary$f;


}



# For slope;

# proper imputation;

bugs_mi_bias=mean(bugs_mi_mean)-true_slope;
bugs_mi_bias;

bugs_mi_bias/true_slope;

bugs_mi_mse=mean((bugs_mi_mean-true_slope)^2);
bugs_mi_mse;

# coverage;
bugs_slope_low95_vec=bugs_mi_mean-qt(.975, bugs_mi_df)*sqrt(bugs_mi_var);
bugs_slope_up95_vec=bugs_mi_mean+qt(.975, bugs_mi_df)*sqrt(bugs_mi_var);

bugs_slope_length=mean(bugs_slope_up95_vec-bugs_slope_low95_vec);
bugs_slope_length;


bugs_slope_coverage=(bugs_slope_low95_vec < true_slope)*(bugs_slope_up95_vec > true_slope);

mean(bugs_slope_coverage);

# variance estimates;
mean(sqrt(bugs_mi_var));
sqrt(var(bugs_mi_mean));

# passive imputation;

pas_mi_bias=mean(pas_mi_mean)-true_slope;
pas_mi_bias;

pas_mi_bias/true_slope;

pas_mi_mse=mean((pas_mi_mean-true_slope)^2);
pas_mi_mse;

# coverage;
pas_slope_low95_vec=pas_mi_mean-qt(.975, pas_mi_df)*sqrt(pas_mi_var);
pas_slope_up95_vec=pas_mi_mean+qt(.975, pas_mi_df)*sqrt(pas_mi_var);

pas_slope_length=mean(pas_slope_up95_vec-pas_slope_low95_vec);
pas_slope_length;

pas_slope_coverage=(pas_slope_low95_vec < true_slope)*(pas_slope_up95_vec > true_slope);

mean(pas_slope_coverage);

# variance estimates;
mean(sqrt(pas_mi_var));
sqrt(var(pas_mi_mean));

# JAV

jav_mi_bias=mean(jav_mi_mean)-true_slope;
jav_mi_bias;

jav_mi_bias/true_slope;

jav_mi_mse=mean((jav_mi_mean-true_slope)^2);
jav_mi_mse;

# coverage;
jav_slope_low95_vec=jav_mi_mean-qt(.975, jav_mi_df)*sqrt(jav_mi_var);
jav_slope_up95_vec=jav_mi_mean+qt(.975, jav_mi_df)*sqrt(jav_mi_var);

jav_slope_length=mean(jav_slope_up95_vec-jav_slope_low95_vec);
jav_slope_length;

jav_slope_coverage=(jav_slope_low95_vec < true_slope)*(jav_slope_up95_vec > true_slope);

mean(jav_slope_coverage);

# variance estimates;
mean(sqrt(jav_mi_var));
sqrt(var(jav_mi_mean));

# make some plots;
par(mfrow=c(2,1));
hist(x[y2==1]);
hist(x[y2==0]);

summary(x[y2==1]);
var(x[y2==1]);
summary(x[y2==0]);
var(x[y2==0]);


# generate the logistic outcome;
beta0=-1.5;
beta1=1/3;
beta2=1/6;

# generate the univariate normal x variable;
mu=2;
sigma=1;

par(mfrow=c(1,1));

rowobs=1000000;
x=mu+sqrt(sigma)*rnorm(rowobs);

y2=rbinom(rowobs,size=1,prob=exp(beta0+beta1*x+beta2*x^2)/(1+exp(beta0+beta1*x+beta2*x^2)));


