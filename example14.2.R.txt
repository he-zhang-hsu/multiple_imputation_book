################## data generate ##############
# Program: boxcox_impute_expolore_simulation; ############
# generate data, and try out different missing data methods;
# run some simulations to assess the biasedness of various methods;

# library(car);
# library(mvtnorm);
library(mice);
library(norm);
# library(HI);
options(digits=4);
rm(list=ls());



parameter_draw=function(data)
{
 # obtain all the computational components;
 p=ncol(data);
 n_total=nrow(data);
 x=cbind(rep(1,n_total), data[,1:(p-1)]);
 y=data[,p];
 # perform least-square calculation;
 beta_hat=solve(t(x)%*%x)%*%t(x)%*%y;
 s_square=1/(n_total-p)*crossprod(y-x%*%beta_hat);
 inv_v_beta=solve(t(x)%*%x);
 
 # draw sigma_square;
 # set.seed(19760421);
 sigma_square=1/(rgamma(1, shape=n_total/2-p/2, scale=2/((n_total-p)*s_square)));
 
 # draw beta;
 beta=mvrnorm(n=1, mu=beta_hat, Sigma=sigma_square*inv_v_beta);

 parameter=c(beta,sigma_square);
 parameter;
}


performance=function(mean_vec, var_vec, true)
{
bias=mean(mean_vec)-true;
rbias=bias/true;
mse=mean((mean_vec-true)^2);
# lower and upper 95% CI;
low95_vec=mean_vec-1.96*sqrt(var_vec);
up95_vec=mean_vec+1.96*sqrt(var_vec);
mean_length=mean(up95_vec-low95_vec);
mean_cov=mean((low95_vec < true)*(up95_vec > true));
sd=sqrt(var(mean_vec));
se=mean(sqrt(var_vec));
estimand=as.data.frame(cbind(bias,rbias,mse,mean_length,mean_cov,sd,se))
}

mi_performance=function(mean_mat, var_mat, true, n)
{
cycle_no=nrow(mean_mat);
mi_mean=rep(NA, cycle_no);
mi_var=rep(NA, cycle_no);
mi_df=rep(NA, cycle_no);
mi_f=rep(NA, cycle_no);

for (i in 1:cycle_no)
{
summary=pool.scalar(mean_mat[i,], var_mat[i,], n=n);
mi_mean[i]=summary$qbar;
mi_var[i]=summary$t;
mi_df[i]=summary$df;
mi_f[i]=summary$f;
}

bias=mean(mi_mean)-true;
rbias=bias/true;
mse=mean((mi_mean-true)^2);
# coverage;
low95_vec=mi_mean-qt(.975, mi_df)*sqrt(mi_var);
up95_vec=mi_mean+qt(.975, mi_df)*sqrt(mi_var);
mean_length=mean(up95_vec-low95_vec);
mean_cov=mean((low95_vec < true)*(up95_vec > true));
se=mean(sqrt(mi_var));
sd=sqrt(var(mi_mean));
estimand=as.data.frame(cbind(bias,rbias,mse,mean_length,mean_cov,sd,se))
}







rowobs=1000;

# set up the random seed;
set.seed(197789);

# generate data;
# distribution of x, the covariate;
# could be normal, or could be other distributions;
# fixed at mean 10, and variance 1;
mu_x=3;
var_x=1;

# regression parameters;
# both beta0 and beta1 are fixed at 
beta0=-2;
beta1=1;


# error variance;
var_error=1;


cycle_no=1000;
mi_no=50;
cut_off=1;

# cut_off=-2;

# cut_off=3;

# matrices holding the parameter estimates;
# complete-data inferences;
y2_mean_vec=y2_var_vec=cc_mean_vec=cc_var_vec=y2_prop_vec=y2_prop_var_vec=y2_cc_prop_vec=y2_cc_prop_var_vec=rep(NA, cycle_no);
y2_cc_prop_raghu_vec=y2_cc_prop_raghu_var_vec=y2_prop_raghu_vec=y2_prop_raghu_var_vec=rep(NA, cycle_no);

obs_prop_mat_uni=obs_prop_var_mat_uni=obs_prop_mat_biv=obs_prop_var_mat_biv=matrix(NA, cycle_no, mi_no);
trans_prop_mat_uni=trans_prop_var_mat_uni=trans_prop_mat_biv=trans_prop_var_mat_biv=matrix(NA, cycle_no, mi_no);
raghu_prop_mat_uni=raghu_prop_var_mat_uni=raghu_prop_mat_biv=raghu_prop_var_mat_biv=matrix(NA, cycle_no, mi_no);

for (cycle in 1:cycle_no)

{
set.seed(cycle);

x=mu_x+sqrt(var_x)*rnorm(rowobs);

# error distribution
# could be normal, or could be other distributions;
error=sqrt(var_error)*rnorm(rowobs);

# generate the latent variable;
y2=beta0+beta1*x+error;


# set up the missing data as MCAR on x;


miss_indi=runif(n=rowobs)<0.40;
y2_miss=y2;
y2_miss[miss_indi==1]=NA;
miss_seq=cbind(seq(1,rowobs,1), miss_indi)[miss_indi==1,1];
obs_no=length(y2_miss[!is.na(y2_miss)]);
y2_obs=y2[miss_indi==0];
mis_no=rowobs-obs_no;

# observed data is cbind(x, y2_miss);

# compelete data analysis;
# sample mean;
y2_mean=mean(y2);
y2_var=var(y2)/rowobs;
y2_mean_vec[cycle]=y2_mean;
y2_var_vec[cycle]=y2_var;


# proportions: methods of moment estimator;
y2_prop=mean(y2<cut_off);
y2_prop_var=y2_prop*(1-y2_prop)/(rowobs-1);
y2_prop_vec[cycle]=y2_prop;
y2_prop_var_vec[cycle]=y2_prop_var;



# proportions: model-based estimator;
# raghu estimator;
y2_prop_raghu=pnorm((cut_off-y2_mean)/sqrt(var(y2)))
y2_prop_raghu_var=(dnorm((cut_off-y2_mean)/sqrt(var(y2))))^2*(1/rowobs+(cut_off-y2_mean)^2/(2*var(y2)^2*(rowobs-1)));
y2_prop_raghu_vec[cycle]=y2_prop_raghu;
y2_prop_raghu_var_vec[cycle]=y2_prop_raghu_var;




# different missing data methods;

# complete-case analysis;
# mean estimands;
cc_mean=mean(y2_miss, na.rm="T");
cc_mean_vec[cycle]=cc_mean;
cc_var_vec[cycle]=var(y2_miss, na.rm="T")/obs_no;

# proportions; method-of-moment estimator;

y2_cc_prop=mean(y2_miss<cut_off, na.rm=T);
y2_cc_prop_var=y2_cc_prop*(1-y2_cc_prop)/(obs_no-1);
y2_cc_prop_vec[cycle]=y2_cc_prop;
y2_cc_prop_var_vec[cycle]=y2_cc_prop_var;

# raghu estimator;

y2_cc_prop_raghu=pnorm((cut_off-mean(y2_obs))/sqrt(var(y2_obs)))
y2_cc_prop_raghu_var=(dnorm((cut_off-mean(y2_obs))/sqrt(var(y2_obs))))^2*(1/obs_no+(cut_off-mean(y2_obs))^2/(2*var(y2_obs)^2*(obs_no-1)));
y2_cc_prop_raghu_vec[cycle]=y2_cc_prop_raghu;
y2_cc_prop_raghu_var_vec[cycle]=y2_cc_prop_raghu_var;


# now impute the missing y2's to get estimates of the marginal;
y2_completed_uni=y2_completed_biv=y2_miss;

mu_hat=mean(y2_obs);
s_square=1/(obs_no-1)*crossprod(y2_obs-mu_hat);



for (i in 1:mi_no)
{

# univariate model imputation
# draw sigma_square;
sigma_square=1/(rgamma(1, shape=obs_no/2-1/2, scale=2/((obs_no-1)*s_square)));
mu=rnorm(1, mu_hat, sd=sqrt(sigma_square/obs_no));

y2_imputed_uni=rnorm(mis_no, mu, sd=sqrt(sigma_square));
y2_completed_uni[miss_seq]=y2_imputed_uni;

# proportions: method of moment estimator;
obs_prop_uni=mean(y2_completed_uni<cut_off);
obs_prop_var_uni=obs_prop_uni*(1-obs_prop_uni)/(rowobs-1);
obs_prop_mat_uni[cycle,i]=obs_prop_uni;
obs_prop_var_mat_uni[cycle,i]=obs_prop_var_uni;

# marginal means;
obs_mean_uni=mean(y2_completed_uni);
# obs_var_uni=var(y2_completed_uni)/rowobs;

# obs_mean_mat[cycle,i]=obs_mean;
# obs_var_mat[cycle,i]=obs_var;


# proportions: Raghu's estimator;
raghu_prop_uni=pnorm((cut_off-obs_mean_uni)/sqrt(var(y2_completed_uni)));
raghu_prop_var_uni=(dnorm((cut_off-obs_mean_uni)/sqrt(var(y2_completed_uni))))^2*(1/rowobs+(cut_off-obs_mean_uni)^2/(2*var(y2_completed_uni)^2*(rowobs-1)));
raghu_prop_mat_uni[cycle,i]=raghu_prop_uni;
raghu_prop_var_mat_uni[cycle,i]=raghu_prop_var_uni;

# bivariate model imputation; 
y2_imputed_biv=mice.impute.norm(y2_miss, ry=as.logical(1-miss_indi), seed=i, x=x);
y2_completed_biv[miss_seq]=y2_imputed_biv;

# proportions: method of moment estimator;
obs_prop_biv=mean(y2_completed_biv<cut_off);
obs_prop_var_biv=obs_prop_biv*(1-obs_prop_biv)/(rowobs-1);
obs_prop_mat_biv[cycle,i]=obs_prop_biv;
obs_prop_var_mat_biv[cycle,i]=obs_prop_var_biv;

# marginal means;
obs_mean_biv=mean(y2_completed_biv);
# obs_var_uni=var(y2_completed_uni)/rowobs;

# obs_mean_mat[cycle,i]=obs_mean;
# obs_var_mat[cycle,i]=obs_var;


# proportions: Raghu's estimator;
raghu_prop_biv=pnorm((cut_off-obs_mean_biv)/sqrt(var(y2_completed_biv)));
raghu_prop_var_biv=(dnorm((cut_off-obs_mean_biv)/sqrt(var(y2_completed_biv))))^2*(1/rowobs+(cut_off-obs_mean_biv)^2/(2*var(y2_completed_biv)^2*(rowobs-1)));
raghu_prop_mat_biv[cycle,i]=raghu_prop_biv;
raghu_prop_var_mat_biv[cycle,i]=raghu_prop_var_biv;




}

cat("the cycle is", cycle, "\n");



}

# the end of multiple imputation;

# plot the distribution of the data;

# check the performance of the estimates;
# population quantity

# For proportion;

# complete-data proportion estimand; methods of moment estimator;

# mean estimand;
true_prop=mean(y2_prop_vec);

BD_moment=performance(y2_prop_vec, y2_prop_var_vec, true_prop);
BD_moment;

BD_efficient=performance(y2_prop_raghu_vec, y2_prop_raghu_var_vec, true_prop);
BD_efficient;



CC_moment=performance(y2_cc_prop_vec, y2_cc_prop_var_vec, true_prop);
CC_moment;


CC_efficient=performance(y2_cc_prop_raghu_vec, y2_cc_prop_raghu_var_vec, true_prop);
CC_efficient;


MI_uni_moment=mi_performance(obs_prop_mat_uni, obs_prop_var_mat_uni, true_prop, rowobs);
MI_uni_moment;


MI_uni_efficient=mi_performance(raghu_prop_mat_uni, raghu_prop_var_mat_uni, true_prop, rowobs);
MI_uni_efficient;

MI_biv_moment=mi_performance(obs_prop_mat_biv, obs_prop_var_mat_biv, true_prop, rowobs);
MI_biv_moment;


MI_biv_efficient=mi_performance(raghu_prop_mat_biv, raghu_prop_var_mat_biv, true_prop, rowobs);
MI_biv_efficient;



